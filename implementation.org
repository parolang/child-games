#+TITLE: Implementation notes for Munchkin Academy

* Tic Tac Toe
First bind cellClick as click handler.
#+BEGIN_SRC js
$(".cell").click(cellClick);
#+END_SRC

Then call idCells to add HTML id to each cell div.
#+BEGIN_SRC js
idCells();
#+END_SRC

** idCells ()
#+BEGIN_SRC js
  var idCells = function () {
      // This function needs to find each .cell element, and give them
      // id's according to their row and position #r0c0, #r0c1, #r0c2,
      // etc.  Also initialize cellIds and board arrays.
      
      $(".row").each(function(i,row) {
          $(row).find(".cell").each(function(j,col) {
              var id = "r"+i.toString()+"c"+j.toString();
              
              $(col).attr("id", id);
              cellIds[i][j] = id;
              board[i][j] = " ";
          });
      });
      console.log("idCells called!");
  };

#+END_SRC

** cellClick
Click handler

We need the HTML id of the cell that was clicked.
#+BEGIN_SRC js
var id = $(this).attr("id");
#+END_SRC

We also need the text content of the clicked cell.
#+BEGIN_SRC js
var cellContent = $(this).text();
#+END_SRC

If the cell is empty, change it to an X.
#+BEGIN_SRC js
  if (cellContent===" ") {
      $(this).text("X");
  }
#+END_SRC

Did the player win?  If so, just write "Win!" to the console for now.
#+BEGIN_SRC js
  if (isWin(cellId, "X")) {
      console.log("Win!");
  }
#+END_SRC


** isWin (cellId, player)
Function

Return true if the player won horizontally, vertically, or
diagonally. Otherwise return false.
#+BEGIN_SRC js
  var playerWin = false;

  playerWin = playerWin || isHorzWin(cellId, player);
  playerWin = playerWin || isVertWin(cellId, player);
  playerWin = playerWin || isDiagWin(cellId, player);

  return playerWin;
#+END_SRC


** isHorzWin (cellId, player)
Lazy method

First define array of all horizontal win combinatons. There are only
three.
#+BEGIN_SRC js
  var win = [[coord2id(0,0), coord2id(0,1), coord2id(0,2)],
             [coord2id(1,0), coord2id(1,1), coord2id(1,2)],
             [coord2id(2,0), coord2id(2,1), coord2id(2,2)]];
#+END_SRC

If all three cells are the player's mark, then return true.
#+BEGIN_SRC js
  var playerWin = true;

  for (var i=0; i<win.length; i+=1) {
      playerWin = playerWin && ($(win[i][0]).text === player);
      playerWin = playerWin && ($(win[i][1]).text === player);
      playerWin = playerWin && ($(win[i][2]).text === player);
  }

  return playerWin;
#+END_SRC



** isVertWin (cellId, player)
Lazy method

First define array of all vertical win combinatons. There are only
three.
#+BEGIN_SRC js
  var win = [[coord2id(0,0), coord2id(1,0), coord2id(2,0)],
             [coord2id(0,1), coord2id(1,1), coord2id(2,1)],
             [coord2id(0,2), coord2id(1,2), coord2id(2,2)]];
#+END_SRC

If all three cells are the player's mark, then return true.
#+BEGIN_SRC js
  var playerWin = true;

  for (var i=0; i<win.length; i+=1) {
      playerWin = playerWin && ($(win[i][0]).text === player);
      playerWin = playerWin && ($(win[i][1]).text === player);
      playerWin = playerWin && ($(win[i][2]).text === player);
  }

  return playerWin;
#+END_SRC


** isDiagWin (cellId, player)
Lazy method

First define array of all diagonal win combinatons. There are only
two.
#+BEGIN_SRC js
  var win = [[coord2id(0,0), coord2id(1,1), coord2id(2,2)],
             [coord2id(2,0), coord2id(1,1), coord2id(0,2)]]; 
#+END_SRC

If all three cells are the player's mark, then return true.
#+BEGIN_SRC js
  var playerWin = true;

  for (var i=0; i<win.length; i+=1) {
      playerWin = playerWin && ($(win[i][0]).text === player);
      playerWin = playerWin && ($(win[i][1]).text === player);
      playerWin = playerWin && ($(win[i][2]).text === player);
  }

  return playerWin;
#+END_SRC


** coord2id (coord)
Decide here, an id-type is of the form "#r0c1".
#+BEGIN_SRC js
  var id = "#r"+coord[0]+"c"+coord[1];
  return id;
#+END_SRC

** id2coord (id)
An id-type is of the form "#r0c1"
#+BEGIN_SRC js
  var coord[0] = rowNum(id);
  var coord[1] = colNum(id);

  return coord;
#+END_SRC

** rowNum
#+BEGIN_SRC js
  // rowNum: Return the row number of a given id.
  // E.g., #R1C2 --> 1
  var rowNum = extractNum(2);
#+END_SRC

** colNum
#+BEGIN_SRC js
  // colNum: Return the column number of a given id.
  // E.g., #R1C2 --> 2
  var colNum = extractNum(4);

#+END_SRC

** extractNum (num)
#+BEGIN_SRC js
  var extractNum = function(n) {
      return function(str) {
          return parseInt(str.charAt(n), 10);
      };
  };
#+END_SRC


** Functions:
- ~coord2id~ (coord), ~id2coord~ (id)
- ~isHorzWin~ (cell, player), ~isVertWin~ (cell, player),
  ~isDiagWin~ (cell, player)
- ~isWin~ (cell, player) = ~isHorzWin~ || ~isVertWin~ || ~isDiagWin~
- ~idCells~ to initialize cell divs with HTML id's e.g. R1C2
- ~cellClick~ is call handler for clicking on a cell

*** Maybe later
- ~rowOf~ (cell), ~colOf~ (cell) returns array of cells
- ~diagCells~ () returns array of cells on diagonals


* Bubble Pop
Should I use HTML Canvas?  Generated canvas bubbles might be more
boring than using animated images.  If I'm drawing bubbles, the
non-canvas method might be worse.


* Matching
Basically add elements to the div for this game. Items should be
spaced out appropriately on the screen.  Each clicked item should look
"selected", probably by coloring the background of the image, or by
placing a translucent box stacked on top of the item.

Two possible "modes" for the game.  The easier mode will have the
first item already selected, and then the matching item just needs to
be selected.  This should be easier for small children to use.  The
more difficult mode will have the player select both items that match.
This might simply be harder because of the difficulty in unselecting
the desired item, and then selecting the new item.  You can't just
select the desired object after selecting two items that don't match.
This might be too difficult for the smallest children.


* Dressing the character
Shouldn't be too hard.  Have the player drag images on top of other
images in the game.  Use transparency for clothes like jackets to
"look like" they wrap around the character.  If I want to get fancy, I
could have some of the clothes be two-layered so that the jacket looks
whole until it is dragged over the character.  The front of the jacket
is dragged in front of the character, but the back of the jacket
disappears behind the character.


* How many?
Space out items across the screen evenly.  Have a clickable row of
numbers.  Player counts the items, and clicks the number.  Each win is
reinforced positively somehow.  Maybe just a smiley face or a star in
the center of the screen.


* Face Torso Legs
Three rows of images.  The center column of images lines up form a
complete character, with head, torso, and legs.  Arrows on each side
of the rows that can be clicked on to slide the row left or right.
Each row is a cycle, so that when the image disappears off of one side
of the screen, it reappears on the other side.  If there are enough
images, they might cycle "behind" the screen until they come back
around again.  There's really no "winning" in this game.
